---
title: 几条汇编指令总结
date: 2018-08-07 09:00:12
tags:
  - 随笔
  - 汇编
cover: https://raw.githubusercontent.com/YiYunC/cloudimg/master/data/03cedb5963ef7add274464539765a1eb.jpg
---

总结几条比较常用的汇编指令。
![](https://raw.githubusercontent.com/YiYunC/cloudimg/master/data/03cedb5963ef7add274464539765a1eb.jpg)

<!--more-->

## 1.LDR ##
load，读内存。
{% codeblock lang:objc %}LDR R0,[R1]{% endcodeblock %}
假设R1的值是x，读取地址x上的数据（4字节），保存到R0中。

## 2.STR ##
store，写内存。
{% codeblock lang:objc %}STR R0,[R1]{% endcodeblock %}
假设R1的值是x，把R0的值写到地址x（4字节）上。

## 3.B ##
back，跳转

## 4.MOV ##
move，赋值。
{% codeblock lang:objc %}
MOV R0,R1       :R0=R1
MOV R0，#0x100  :R0=0x100。
{% endcodeblock %}

## 5.伪指令 ##
{% codeblock lang:objc %}LDR R0，=0x12345678  :R0=0x12345678{% endcodeblock %}
这条指令会被拆分成几条真正的RAM指令。
为什么会有伪指令的存在，例如MOV RO，#0x12345678这条指令是错误的，因为32位的ARM指令中总有一位表示MOV，还有一位表示R0，剩下的位数不足32位，不能表示任意数，只能表示简单值（叫做**立即数**）。


## 6.add、sub ##
{% codeblock lang:objc %}
add r0,r1,#4  :r0=r1+4
sub r0,r1,#4  :r0=r1-4
sub r0,r1,r2  :r0=r1-r2
{% endcodeblock %}

## 7.BL ##
**branch and link**
bl xxx表示：1.跳到xxx;2.把返回地址（下一条指令的地址）保存在lr寄存器中。

## 8.ldm、stm ##
ldm:读内存，写入多个寄存器。
stm:把多个寄存器的值写入内存。
ldmia（increment after）：过后增加
stmdb（decrement before）：预先减少

### stmdb ###
{% codeblock lang:objc %}stmdb sp!,{fp,ip,lr,pc}{% endcodeblock %}
这条指令中，首先假设sp=4096，那么由stmdb可知1.先减sp'=sp-4=4092;2.后存4092~4095存放pc的值；3.先减sp'=sp-4=4088;4.后存4088~4091存放lr的值；.....依次循环。其中sp!表示sp=最终的被修改的sp值4080。
注：高编号寄存器存在高地址，fp、ip、sp、ls、pc的编号分别是r11、r12、r13、r14、r15。

### ldmia ###
{% codeblock lang:objc %}ldmia sp,{fp,sp,pc}{% endcodeblock %}
这条指令中，由ldmia可知1.先读fp=4080~4083的值即原来保存的fp；2.后增sp'=sp+4=4084;3.先读sp=4084~4087的值即原来保存的ip;4.后增sp'=sp+4=4088；.....依次循环。其中sp无!则表示修改后的地址值不存入sp。


